import constants
import typing
import math
import re
import collections
import numpy as np
import json
from dataclasses import dataclass
from ..enums import Material, HideFlags, SoundType, ParticleType, CustomSpawnEggType, PotionEffect
from .subcollections import Lore
from .dataclass import Enchantment
from ..utils import nbt_dict_to_str, NBTWrapper
from constants import DEFAULT_VAL, DEFAULT_SOUND_PITCH, DEFAULT_SOUND_VOL


class Item:
    """
    Represents a Minecraft Item stack.

    `Attributes`:
    -------------
        `material`: Instance of `Material` enum, tells what kind of item this is.

        `amount`: The amount there is in this Item stack. (From 1 to 64 - any number outside those bounds will error!)

        `name`: The item's name (str).

        `lore`: The item's lore, as an instance of Lore.

        `enchantments`: A list containing instances of Enchantment.

        `damage`: How broken this item is (0 = not broken at all; the higher, the closer to breaking it is). The max
        amount this attribute can have depends on the item's durability, for which there are many lists online.

        `unbreakable`: Boolean; if True, this item cannot lose durability, and remains at damage = 0.

        `hide_flags`: Flags to be hidden. Use the HideFlags enum for this. One flag is of the form HideFlag.FLAG_NAME,
        while, to use more than one, add them up (HideFlag.FLAG_NAME + HideFlag.OTHER_FLAG_NAME + ...). There is also
        HideFlag.ALL which has all flags added up already for you. So, you can select to hide "all but FLAG_NAME" by
        using subtraction: HideFlag.ALL - HideFlag.FLAG_NAME (generically speaking).

        `leather_armor_color`: An integer that represents the color of a leather armor. Tip: write `0x......` for a
        hexadecimal representation. (This is not present in non-leather armor items.)

        `entity_tag`: str,dict or None (depending on what is given by the user) of NBT. Any NBT that modifies entities
        generated by either spawn eggs, the armor stand item or tropical fish buckets. (For other `Material`s, this
        attribute should always be None.)

        `extra_tags`: str,dict or None of NBT, representing any extra tags not covered here.
    """
    __slots__ = (
        "material", "_amount", "name", "lore", "enchantments", "damage", "unbreakable", "hide_flags",
        "leather_armor_color", "entity_tag", "extra_tags"
    )

    def __init__(
            self, material: Material, amount: int = 1,
            *, name: typing.Optional[typing.Union[str, "DFText"]] = None,
            lore: typing.Union[Lore, collections.Iterable[typing.Optional[str]]] = Lore(),
            enchantments: typing.Optional[typing.Iterable[Enchantment]] = None,
            damage: int = 0, unbreakable: bool = False, hide_flags: typing.Optional[HideFlags] = None,
            leather_armor_color: typing.Optional[int] = None,
            entity_tag: typing.Optional[typing.Union[dict, str]] = None,
            extra_tags: typing.Optional[typing.Union[dict, str]] = None
    ):
        """
        Initialize the item stack.

        :param material: Instance of the Materials enum; represents what this item actually is.
        :param amount: The amount of items in this item stack, between 1 and 64. By default, 1.
        :param name: An optional custom name to be given to this item, as a `str` or `DFText`. Default: None
        :param lore: A Lore for this item (either Lore instance or list of `str`). Default: empty Lore instance.
        :param enchantments: A list of `Enchantment` instances.
        :param damage: The damage of this item (i.e., amount of uses so far). Defaults to 0 (not used).
        :param unbreakable: Bool, whether or not this item is unbreakable. Defaults to False.
        :param leather_armor_color: If this is a piece of leather armor, specify its color through an integer. Tip: Use
            0x...... for hexadecimal colors.
        :param entity_tag: An optional str or dict representing Entity NBT tags applied on entities that are spawned
            through this item. Applies to the materials: (X)_SPAWN_EGG; TROPICAL_FISH_BUCKET; ARMOR_STAND. Default:
            None
        :param extra_tags: Any extra NBT tags you'd like to give your item, either as a dict of NBT tags or a valid NBT
            str. Please ensure those tags do not conflict with the previous ones to avoid spooky errors in DiamondFire.
            Default: None. (Please ensure this is a valid TAG_Compound in NBT, a.k.a. `dict` in pythonic language.)
        """
        self.material: Material = material
        self._amount: int = 1
        self.amount = amount
        self.name: str = str(name)
        self.lore: Lore = Lore(lore)

        if enchantments and any(type(i) != Enchantment for i in enchantments):
            raise TypeError("Non-Enchantment instance found in given 'enchantments' arg.")

        self.enchantments = list(enchantments) if enchantments else []

        self.damage: int = int(damage)

        self.unbreakable: bool = bool(unbreakable)

        self.hide_flags: HideFlags = hide_flags

        if self.material in (
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS
        ):
            self.leather_armor_color: typing.Optional[int] = int(leather_armor_color) \
                if leather_armor_color is not None else None
        else:
            self.leather_armor_color: typing.Optional[int] = None

        if "SPAWN_EGG" in self.material.value.upper() or self.material in (
            Material.ARMOR_STAND, Material.TROPICAL_FISH_BUCKET
        ):
            self.entity_tag: typing.Optional[typing.Union[dict, str]] = entity_tag
        else:
            self.entity_tag: typing.Optional[typing.Union[dict, str]] = None

        self.extra_tags = extra_tags

    @property
    def amount(self) -> int:
        return self._amount

    @amount.setter
    def amount(self, new_amt: int) -> None:
        i_n_amt = int(new_amt)
        if i_n_amt > constants.MAX_ITEM_STACK_SIZE:
            raise ValueError(f"Maximum item stack size is {constants.MAX_ITEM_STACK_SIZE}!")

        if i_n_amt < constants.MIN_ITEM_STACK_SIZE:
            raise ValueError(f"Minimum item stack size is {constants.MIN_ITEM_STACK_SIZE}!")

        self._amount = i_n_amt

    def as_nbt(self) -> str:
        """
        Returns this item as a NBT string.

        :return: SNBT string.
        """
        tag_dict = dict(
            *(dict(Damage=int(self.damage)) if self.damage != 0 else dict()),
            *(dict(Unbreakable=NBTWrapper("1b")) if self.unbreakable else dict()),  # NBTWrapper is used to ensure
            *(dict(                                                                 # quotes aren't used
                EntityTag=(
                    nbt_dict_to_str(self.entity_tag) if type(self.entity_tag) == dict else NBTWrapper(self.entity_tag)
                ) if self.entity_tag else dict()
            )),
            *(dict(
                display=dict(
                    *(dict(color=self.leather_armor_color) if self.leather_armor_color is not None else dict()),
                    *(dict(Name=json.dumps(str(self.name))) if self.name else dict()),
                    *(dict(Lore=self.lore.as_json_data() if self.lore else dict()))
                ) if any([self.leather_armor_color is not None, self.name, self.lore]) else dict()
            )),
            *(dict(HideFlags=self.hide_flags.value) if self.hide_flags and self.hide_flags.value else dict())
        )
        if type(self.extra_tags) == str:
            tag_dict["extra_tags"] = NBTWrapper(self.extra_tags)

        elif type(self.extra_tags) == dict:
            tag_dict.update(self.extra_tags)

        dict_with_data = dict(
            id=f"minecraft:{self.material.value}",
            Count=NBTWrapper(f"{min(max(self.amount, 1), 64)}b"),  # TODO: Finish this NBT
            tag=tag_dict
        )

        return nbt_dict_to_str(dict_with_data)

    def as_json_data(self) -> dict:
        """
        Returns this item as valid DF json representation (as a dict, not as a string).

        :return: Dict
        """
        return dict(
            id=constants.ITEM_ID_ITEM,
            data=dict(
                item=self.as_nbt()  # it seems "DF_NBT = 1976" is just a means of representing version; can be ignored.
            )
        )

    # def from_json_data(self) -> "Item":
    #     pass  # TODO - ok now, this will be hard... gotta interpret NBT

    def to_item(self) -> "Item":
        return self  # well... yeah

    def set(self, material: Material = DEFAULT_VAL, *args, **kwargs) -> None:
        """
        Refer to __init__'s documentation.
        """
        # TODO: finish
        pass

    def copy(self) -> "Item":
        """
        Makes an identical copy of this item stack.

        :return: New item.
        """
        return Item(
            self.material, self.amount, lore=self.lore, enchantments=self.enchantments, damage=self.damage,
            unbreakable=self.unbreakable, leather_armor_color=self.leather_armor_color, entity_tag=self.entity_tag,
            extra_tags=self.extra_tags
        )

    def __repr__(self):
        return f"<{self.__class__.__name__} minecraft:{self.material.value} x {self.amount}>"

    def __str__(self):
        return f"minecraft:{self.material.value}"

    def __eq__(self, other: "Item"):
        attrs_to_compare = set(self.__class__.__slots__) - {"_amount", }  # compare all except amount

        return type(self) == type(other) and all(
            getattr(self, attr) == getattr(other, attr) for attr in attrs_to_compare
        )

    def __ne__(self, other: "Item"):
        return not self.__eq__(other)

    def __gt__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount > other._amount

    def __ge__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount >= other._amount

    def __lt__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount < other._amount

    def __le__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount <= other._amount

    def __mul__(self, other: typing.Union[int, "Item"]):  # can be an Item if it is == to current instance.
        new = self.copy()
        new.amount *= other._amount if self == other else other
        return new

    def __rmul__(self, other: typing.Union[int, "Item"]):
        return self.__mul__(other)

    def __add__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount += other._amount if self == other else other
        return new

    def __radd__(self, other: typing.Union[int, "Item"]):
        return self.__add__(other)

    def __pow__(self, power: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount **= power._amount if self == power else power
        return new

    def __truediv__(self, other: typing.Union[int, "Item"]):  # always rounded.
        return self.__floordiv__(other)

    def __floordiv__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount //= other._amount if self == other else other
        return new

    def __sub__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount -= other._amount if self == other else other
        return new

    def __ceil__(self):
        return self

    def __floor__(self):
        return self

    def __abs__(self):
        return self

    def __pos__(self):
        return self


class DFText(collections.UserString):
    """
    Represents a DiamondFire Text variable. (note: this is not a dynamic variable.)

    Subclasses `collections.UserString`; therefore, supports all str operations.

    `Attributes`:
        data: The value of the text variable. String.

        convert_color: Whether or not should convert "&" to "§" (section sign) to allow easier color code writing.
            Defaults to True.
    """
    __slots__ = ("convert_color",)
    convert_color: bool

    def __init__(self, text: str = "", *, convert_color: bool = True):
        """
        Init text variable.

        :param text: Text, defaults to "" (empty str).
        :param convert_color: Boolean; whether or not should convert &x to color codes (§x). (Defaults to True)
        """
        super().__init__(text)
        self.data = text
        self.convert_color = bool(convert_color)

    def set(self, new_text: str) -> "DFText":
        """
        Set the value of this text variable.

        :param new_text: The new text.

        :return: self to allow chaining
        """
        self.data = new_text

        return self

    def as_json_data(self) -> dict:
        """
        Obtain this variable represented as a JSON object (dict).

        :return: Dict.
        """
        converted_str: str = re.sub(
            constants.STR_COLOR_CODE_REGEX, constants.SECTION_SIGN + r"\1", self.data
        ) if self.convert_color else self.data  # convert color

        return dict(
            id=constants.ITEM_ID_TEXT_VAR,
            data=dict(
                name=converted_str
            )
        )

    @classmethod
    def from_json_data(cls, data: dict):
        """
        Obtain variable from pre-existing parsed JSON data.

        :param data: The parsed JSON dict.
        :return: DFText instance.
        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "name" not in data["data"]
            or not type("name") == str
        ):
            raise TypeError(
                "Malformed DFText parsed JSON data! Must be a dict with, at least, a 'data' dict and a name str value."
            )

        return cls(data["data"]["name"])

    def to_item(self) -> Item:
        pass  # TODO: implement this as book and stuff

    def __repr__(self):
        return f"<{self.__class__.__name__} data='{self.data}'>"


AnyNumber = typing.Union[int, float]


class DFNumber:
    """
    Represents a DiamondFire Number variable.

    Supports practically all int/float-related operations and comparisons.

    `Attributes`:
        value: The value of the number variable. Float.
    """
    __slots__ = ("_value",)
    _value: float

    def __init__(self, value: AnyNumber = 0.0):
        """
        Init number variable.

        :param value: Integer or float, defaults to 0
        """
        self.value = value

    @property
    def value(self) -> float:
        """
        The value of this number variable.

        :return: Float representing the value.
        """
        return self._value

    @value.setter
    def value(self, new_value: AnyNumber):
        """
        Set the value of this number variable.

        :param new_value: The new value.
        """
        self._value = float(new_value)

    def set(self, new_value: AnyNumber) -> "DFNumber":
        """
        Set the value of this number variable.

        :param new_value: The new value.
        """
        self._value = float(new_value)

        return self

    def as_json_data(self) -> dict:
        """
        Obtain this variable represented as a JSON object (dict).

        :return: Dict.
        """
        return dict(
            id=constants.ITEM_ID_NUMBER_VAR,
            data=dict(
                name=str(self.value)
            )
        )

    @classmethod
    def from_json_data(cls, data: dict):
        """
        Obtain variable from pre-existing parsed JSON data.
        :param data: The parsed JSON dict.
        :return: DFNumber instance.
        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "name" not in data["data"]
            or not type("name") in (int, float, str)
        ):
            raise TypeError(
                "Malformed DFNumber parsed JSON data! Must be a dict with, at least, a 'data' dict and a name value."
            )

        return cls(float(data["data"]["name"]))

    def copy(self):
        return DFNumber(self.value)

    def to_item(self) -> Item:
        pass  # TODO: implement this as slimeball and stuff

    @staticmethod
    def _extract_val(possible_num: typing.Union[int, float, "DFNumber"]):
        if isinstance(possible_num, DFNumber):
            return possible_num.value

        return possible_num

    def __repr__(self):
        return f"<{self.__class__.__name__} value={self.value}>"

    def __str__(self):
        return str(self.value)

    def __eq__(self, other):
        return type(self) == type(other) and self.value == other.value

    def __ne__(self, other):
        return not self.__eq__(other)

    def __gt__(self, other):
        return self.value > DFNumber._extract_val(other)

    def __ge__(self, other):
        return self.value >= DFNumber._extract_val(other)

    def __lt__(self, other):
        return self.value < DFNumber._extract_val(other)

    def __le__(self, other):
        return self.value <= DFNumber._extract_val(other)

    def __add__(self, other):
        return DFNumber(self.value + DFNumber._extract_val(other))

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        return DFNumber(self.value - DFNumber._extract_val(other))

    def __rsub__(self, other):
        return DFNumber((+other) - self.value)

    def __mul__(self, other):
        return DFNumber(self.value * DFNumber._extract_val(other))

    def __rmul__(self, other):
        return self.__mul__(other)

    def __mod__(self, other):
        return DFNumber(self.value % DFNumber._extract_val(other))

    def __rmod__(self, other):
        return other % self.value

    def __truediv__(self, other):
        return DFNumber(self.value / DFNumber._extract_val(other))

    def __floordiv__(self, other):
        return DFNumber(self.value // DFNumber._extract_val(other))

    def __pow__(self, power):
        return DFNumber(self.value ** DFNumber._extract_val(power))

    def __neg__(self):
        return DFNumber(-self.value)

    def __pos__(self):
        return self

    def __abs__(self):
        return DFNumber(abs(self.value))

    def __ceil__(self):
        return DFNumber(math.ceil(self.value))

    def __floor__(self):
        return DFNumber(math.floor(self.value))


class DFLocation:
    """
    Represents a DiamondFire Location.

    `Attributes`:
    -------------
        x: The value of the x position (float).

        y: The value of the y position (float).

        z: The value of the z position (float).

        pitch: The pitch value (float).

        yaw: The yaw value (float).

        is_block: Whether or not this location represents a solid (non-air) block. (bool) Defaults to False.

        world_least: A constant int related to DF; this shouldn't need to be defined by the library user.

        world_most: A constant int related to DF; this shouldn't need to be defined by the library user.

    `Supported comparisons`:
    ------------------------
        `a == b`: True if `a` and `b` have the same x,y,z,pitch,yaw, False if at least one is different.

        `a != b`: Negation of `a == b`.

        `a > b`: True if at least one of the coordinates x,y,z of a is bigger than the respective coordinate in b;
            False otherwise.

        `a < b`: True if at least one of the coordinates x,y,z of a is smaller than the respective coordinate in b;
            False otherwise.

        `a >= b`: Applies `>=` between each coordinate x,y,z of a and b.

        `a <= b`: Applies `<=` between each coordinate x,y,z of a and b.


    `Supported operations`:
    ----------------------
        (Note: They are all applied in-place with given values, not dynamically in DiamondFire!)

        `a + b`: Adds two locations' x, y, z; pitch, yaw (mod 360 degrees). If `b` is an iterable (tuple, list etc.),
            then the respective items 0-4 are added as x,y,z;pitch,yaw. If `b` is an int/float, it is added to x,y,z.

        `a - b`: Follows same rules as addition, except that it is a subtraction.

        `a * b`: Again, same rules as addition, but multiplication.

        `a / b`: Same rules as addition, but division.

        `a // b`: Same rules as division, but floors.

        `a ** b`: Same rules as addition, but as exponentiation.

        `-a`: Applies -1 times x,y,z; pitch, yaw of a.

        `abs(a)`: Applies abs() to x,y,z,pitch,yaw of a.

        `+a`: Returns a.
    """
    __slots__ = ("x", "y", "z", "pitch", "yaw", "is_block")  # , "world_least", "world_most")

    x: float
    y: float
    z: float
    pitch: float
    yaw: float
    is_block: bool
    # world_least: typing.Optional[int]
    # world_most: typing.Optional[int]

    def __init__(
        self, x: AnyNumber = 0.0, y: AnyNumber = 0.0, z: AnyNumber = 0.0, pitch: AnyNumber = 0.0,
        yaw: AnyNumber = 0.0,
        *, is_block: bool = False,
        # world_least: typing.Optional[int] = None, world_most: typing.Optional[int] = None  # locs are now relative
    ):                                                                                       # to the plot
        """
        Init the location.

        :param x: The value of the x position (float).
        :param y: The value of the y position (float).
        :param z: The value of the z position (float).
        :param pitch: The pitch value (float).
        :param yaw: The yaw value (float).
        :param is_block: Whether or not this location represents a solid (non-air) block. (bool) Defaults to False.
        """
        # :param world_least: A constant int related to DF; this shouldn't need to be defined by the library user. None
        #   to let the library handle it.
        # :param world_most: A constant int related to DF; this shouldn't need to be defined by the library user. None
        #   to let the library handle it.
        self.x = float(x)
        self.y = float(y)
        self.z = float(z)
        self.pitch = float(pitch)
        self.yaw = float(yaw)
        self.is_block = bool(is_block)
        # self.world_least = None if world_least is None else int(world_least)
        # self.world_most = None if world_most is None else int(world_most)

    def set(
        self, x: AnyNumber = DEFAULT_VAL, y: AnyNumber = DEFAULT_VAL, z: AnyNumber = DEFAULT_VAL,
        pitch: AnyNumber = DEFAULT_VAL, yaw: AnyNumber = DEFAULT_VAL,
        *, is_block: bool = DEFAULT_VAL,
        # world_least: typing.Optional[int] = DEFAULT_VAL, world_most: typing.Optional[int] = DEFAULT_VAL
    ) -> "DFLocation":
        """
        Set the location.

        :param x: The value of the x position (float).
        :param y: The value of the y position (float).
        :param z: The value of the z position (float).
        :param pitch: The pitch value (float).
        :param yaw: The yaw value (float).
        :param is_block: Whether or not this location represents a solid (non-air) block. (bool) Defaults to False.
        :return: self to allow chaining
        """
        # :param world_least: A constant int related to DF; this shouldn't need to be defined by the library user. None
        #   to let the library handle it.
        # :param world_most: A constant int related to DF; this shouldn't need to be defined by the library user. None
        #   to let the library handle it

        self.x = self.x if x == DEFAULT_VAL else float(x)
        self.y = self.y if y == DEFAULT_VAL else float(y)
        self.z = self.z if z == DEFAULT_VAL else float(z)
        self.pitch = self.pitch if pitch == DEFAULT_VAL else float(pitch)
        self.yaw = self.yaw if yaw == DEFAULT_VAL else float(yaw)
        self.is_block = self.is_block if is_block == DEFAULT_VAL else bool(is_block)
        # self.world_least = self.world_least if world_least == DEFAULT_VAL else (
        #     None if world_least is None else int(world_least)
        # )
        # self.world_least = self.world_most if world_most == DEFAULT_VAL else (
        #     None if world_most is None else int(world_most)
        # )

        return self

    def set_to_other(self, loc: "DFLocation") -> "DFLocation":
        """
        Imports another location's values into this one, making it identical.

        :param loc: Other location to set.
        :return: self
        """
        return self.set(
            loc.x, loc.y, loc.z, loc.pitch, loc.yaw, is_block=loc.is_block,
            # world_least=loc.world_least, world_most=loc.world_most
        )

    def as_json_data(self) -> dict:
        """
        Obtain this location represented as a JSON object (dict).

        :return: Dict.
        """
        return dict(
            id=constants.ITEM_ID_LOCATION,
            data=dict(
                isBlock=self.is_block,
                x=self.x,
                y=self.y,
                z=self.z,
                pitch=self.pitch,
                yaw=self.yaw,
                # worldLeast=constants.LOC_DEFAULT_WORLD_LEAST if self.world_least is None else int(self.world_least),
                # worldMost=constants.LOC_DEFAULT_WORLD_MOST if self.world_most is None else int(self.world_most)
            )
        )

    @classmethod
    def from_json_data(cls, data: dict) -> "DFLocation":
        """
        Obtain variable from pre-existing parsed JSON data.

        :param data: The parsed JSON dict.
        :return: DFNumber instance.
        """
        required_attrs = ("x", "y", "z", "isBlock", "pitch", "yaw", "worldLeast", "worldMost")
        if (
                not isinstance(data, dict)
                # or "id" not in data
                or "data" not in data
                or not isinstance(data["data"], dict)
                or not all(attr in data["data"] for attr in required_attrs)
        ):
            raise TypeError(
                f"Malformed DFLocation parsed JSON data! Must be a dict with a 'data' dict including the \
                following attributes: {', '.join(required_attrs)}."
            )

        d_dict = data["data"]

        return cls(
            d_dict.x, d_dict.y, d_dict.z, d_dict.pitch, d_dict.yaw,
            is_block=d_dict.isBlock,
            # world_least=None if int(d_dict.worldLeast) == constants.LOC_DEFAULT_WORLD_LEAST else d_dict.worldLeast,
            # world_most=None if int(d_dict.worldMost) == constants.LOC_DEFAULT_WORLD_MOST else d_dict.worldMost
        )

    def copy(self):
        """
        Creates an identical copy of this location.
        :return: Copied location.
        """
        new_loc = DFLocation()
        new_loc.set_to_other(self)
        return new_loc

    def _exec_arithmetic(
        self, other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ], arithmetic: typing.Callable, *, op_name: str
    ):
        """
        Executes some arithmetic within the Location and returns a new one.

        :param other: The other DFLocation, an iterable with x,y,z,pitch,yaw (or None to keep),
            or a float that is distributed upon x,y,z.
        :param arithmetic: The function that executes the operation.
        :param op_name: The operation name, to be used in the Error message.
        :return: New DFLocation.
        :raises TypeError: Invalid type provided for arithmetic.
        """
        new_loc = self.copy()

        if type(other) == DFLocation:
            x, y, z, pitch, yaw = map(float, (other.x, other.y, other.z, other.pitch, other.yaw))

        elif isinstance(other, collections.Iterable):
            attr_list = [None] * 5  # initialize an empty array
            for i, value in enumerate(other):
                if i > len(attr_list) - 1:
                    break  # we don't need more values.

                attr_list[i] = value

            x, y, z, pitch, yaw = attr_list

        elif type(other) in (int, float):
            num = float(other)
            x, y, z = [num] * 3
            pitch, yaw = [None] * 2

        else:
            raise TypeError(f"Invalid type for DFLocation {op_name}: {type(other)}!")

        for attr, val in zip(("x", "y", "z"), (x, y, z)):
            if val is None:
                continue  # keep current value

            old_val = getattr(new_loc, attr)

            if op_name == "division" and old_val == val == 0:
                continue  # nope; division by zero

            setattr(new_loc, attr, float(arithmetic(float(old_val), float(val))))

        for mod_attr, val in zip(("pitch", "yaw"), (pitch, yaw)):  # gotta do this mod 360, they're rotation values.
            if val is None:
                continue  # keep current value

            old_val = getattr(new_loc, mod_attr)

            if op_name == "division" and old_val == val == 0:
                continue  # nope; division by zero

            result_val = float(
                arithmetic(float(old_val), float(val))
            )
            setattr(
                new_loc, mod_attr, np.sign(result_val) * (abs(result_val) % constants.MAX_DEGREES)
            )                                                       # mod 360 degrees, while keeping the sign (- or +).

        return new_loc

    def __eq__(self, other: "DFLocation") -> bool:
        """
        Check if this DFLocation is STRICTLY equal to another, except for world_least and world_most (which depend on
        the world).

        :param other: Other DFLocation to compare.
        :return: True if equal, False otherwise.
        """

        attrs_to_check = set(self.__class__.__slots__)  # - {"world_least", "world_most"}
        return type(self) == type(other) and all(getattr(self, attr) == getattr(other, attr) for attr in attrs_to_check)

    def __ne__(self, other: "DFLocation"):
        return not self.__eq__(other)

    def __gt__(self, other: "DFLocation") -> bool:
        """
        Checks if at least one of the coordinates of this location is higher than the other's.

        :param other: Other DFLocation to compare.
        :return: Bool.
        """
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return any(getattr(self, attr) > getattr(other, attr) for attr in positional_attrs)

    def __ge__(self, other: "DFLocation") -> bool:
        """
        Checks if at least one of the coordinates of this location is higher than the other's, or if they are all
        equal.

        :param other: Other DFLocation to compare.
        :return: Bool.
        """
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return all(getattr(self, attr) >= getattr(other, attr) for attr in positional_attrs)

    def __lt__(self, other: "DFLocation") -> bool:
        """
        Checks if at least one of the coordinates of this location is lower than the other's.

        :param other: Other DFLocation to compare.
        :return: Bool.
        """
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return any(getattr(self, attr) < getattr(other, attr) for attr in positional_attrs)

    def __le__(self, other: "DFLocation") -> bool:
        """
        Checks if at least one of the coordinates of this location is lower than the other's, or if they are all equal.

        :param other: Other DFLocation to compare.
        :return: Bool.
        """
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return all(getattr(self, attr) <= getattr(other, attr) for attr in positional_attrs)

    def __repr__(self):
        return f"<{self.__class__.__name__} x={self.x} y={self.y} z={self.z} pitch={self.pitch} yaw={self.yaw}>"

    def __str__(self):
        return str((self.x, self.y, self.z, self.pitch, self.yaw))

    def __getitem__(self, item: typing.Union[int, str, slice]):
        if item in self.__class__.__slots__:  # ["x"]
            return getattr(self, item)  # give them self.x

        positional_attrs = (self.x, self.y, self.z)
        return positional_attrs[item]  # [0] = x ; [1] = y ; [2] = z

    def __setitem__(self, key: typing.Union[int, str, slice], value: typing.Union[int, float]):
        fl_val = float(value)
        if key in self.__class__.__slots__:
            return setattr(self, key, fl_val)

        pos_attrs = ("x", "y", "z")
        attr_s_to_set = pos_attrs[key]
        if type(attr_s_to_set) == str:
            setattr(self, attr_s_to_set, fl_val)
        else:
            for attr_name in attr_s_to_set:
                setattr(self, attr_name, fl_val)

    def __iter__(self):
        for coord in (self.x, self.y, self.z):
            yield coord

    def __add__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        """
        Adds up the coordinates (x,y,z) of two locations and their respective pitches and yaws (mod 360).

        :param other: Other location to add to this one, an iterable with x,y,z, pitch, yaw, or a float that will
            be added to all of the x, y, z.
        :return: Added up location.
        """
        return self._exec_arithmetic(other, np.add, op_name="addition")

    def __radd__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self.__add__(other)

    def __sub__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        """
        Subtracts the coordinates (x,y,z) of two locations and their respective pitches and yaws (mod 360).

        :param other: Other location to subtract from this, an iterable x,y,z, pitch, yaw, or a float that will
            be subtracted from all of the x, y, z.
        :return: New location.
        """
        return self._exec_arithmetic(other, np.subtract, op_name="subtraction")

    def __rsub__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return DFLocation.__add__(-self, other)

    def __mul__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
            ]
    ) -> "DFLocation":
        """
        Multiplies the coordinates (x,y,z) of two locations and their respective pitches and yaws (mod 360).

        :param other: Other location to multiply by this, an iterable x,y,z, pitch, yaw to mult., or a float that will
            multiply each of x, y, z.
        :return: New location.
        """
        return self._exec_arithmetic(other, np.multiply, op_name="multiplication")

    def __rmul__(
            self,
            other: typing.Union[
                "DFLocation",
                typing.Iterable[typing.Optional[AnyNumber]],
                AnyNumber
            ]
    ) -> "DFLocation":
        return self.__mul__(other)

    def __truediv__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        """
        Divides the coordinates (x,y,z) of one location from another and their respective pitches and yaws (mod 360).

        :param other: Other location to divide this, an iterable x,y,z, pitch, yaw to divide, or a float that will
            divide each of x, y, z.
        :return: New location.
        """
        return self._exec_arithmetic(other, np.true_divide, op_name="division")

    def __floordiv__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        """
        Divides the coordinates (x,y,z) of one location from another and their respective pitches and yaws (mod 360).

        :param other: Other location to divide this, an iterable x,y,z, pitch, yaw to divide, or a float that will
            divide each of x, y, z.
        :return: New location.
        """
        return self._exec_arithmetic(other, np.floor_divide, op_name="division")

    def __pow__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Iterable[typing.Optional[AnyNumber]],
            AnyNumber
            ]
    ) -> "DFLocation":
        """
        Powers the coordinates (x,y,z) of two locations and their respective pitches and yaws (mod 360).

        :param other: Other location as power this will be taken to, an iterable x,y,z, pitch, yaw to power this to,
            or a float that will be the power for each of x, y, z.
        :return: New location.
        """
        return self._exec_arithmetic(other, np.float_power, op_name="power")

    def __neg__(self):
        """
        Applies -1 • every single coordinate and pitch/yaw.

        :return: New location.
        """
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, -1 * (getattr(self, attr)))

        return new_loc

    def __pos__(self):
        return self

    def __abs__(self):
        """
        Returns abs() applied to every coordinate and pitch/yaw.

        :return: New location.
        """
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, abs(getattr(self, attr)))

        return new_loc

    def __ceil__(self):
        """
        Returns `math.ceil()` applied to every coordinate and pitch/yaw.

        :return: New location.
        """
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, float(math.ceil(getattr(self, attr))))

        return new_loc

    def __floor__(self):
        """
        Returns `math.floor()` applied to every coordinate and pitch/yaw.

        :return: New location.
        """
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, float(math.floor(getattr(self, attr))))

        return new_loc


class DFSound:
    """
    Used for DF Sounds (Blaze Death, XP Level up etc.)

    `Attributes`:
    -------------
        `sound_type`: The SoundType enum instance that specifies which sound is this.

        `pitch`: The pitch of this sound (float). Defaults to 1.0

        `volume`: The volume of this sound (int). Defaults to 2
    """
    __slots__ = ("sound_type", "pitch", "volume")
    sound_type: SoundType
    pitch: float
    volume: int

    def __init__(
        self, sound_type: SoundType, *, volume: int = DEFAULT_SOUND_VOL,
        pitch: AnyNumber = DEFAULT_SOUND_PITCH
    ):
        if not isinstance(sound_type, SoundType):
            raise TypeError("Sound type must be an instance of SoundType enum.")

        self.sound_type: SoundType = sound_type
        self.pitch: float = float(pitch)
        self.volume: int = int(volume)

    def set(
        self, sound_type: SoundType = DEFAULT_VAL, pitch: AnyNumber = DEFAULT_VAL, volume: int = DEFAULT_VAL
    ) -> None:
        """
        Immediately modify this DFSound. Note that this is not changed dynamically, in DiamondFire. For that,
        use a dynamic variable.

        :param sound_type: The new sound type. (Can be omitted)
        :param pitch: The new sound pitch. (Can be omitted)
        :param volume: The new volume. (Can be omitted)
        """
        if not isinstance(sound_type, SoundType) and sound_type != DEFAULT_VAL:
            raise TypeError("Sound type must be an instance of SoundType enum.")

        self.sound_type = self.sound_type if sound_type == DEFAULT_VAL else sound_type
        self.pitch = float(self.pitch if pitch == DEFAULT_VAL else pitch)
        self.volume = int(self.volume if volume == DEFAULT_VAL else volume)

    def to_item(self) -> "Item":
        pass  # TODO: Sea shell and crap

    def as_json_data(self) -> dict:
        """
        Representation of this DFSound as a valid json-serializable dict.

        :return: Dict
        """
        return dict(
            id=constants.ITEM_ID_SOUND,
            data=dict(
                sound=self.sound_type.value,
                pitch=float(self.pitch),
                vol=int(self.volume)
            )
        )

    @classmethod
    def from_json_data(cls: typing.Type["DFSound"], data: dict) -> "DFSound":
        """
        Obtain DFSound from pre-existing parsed JSON data.

        :param data: The parsed JSON dict.
        :return: DFSound instance.
        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "sound" not in data["data"]
            or not type("sound") == str
        ):
            raise TypeError(
                "Malformed DFSound parsed JSON data! Must be a dict with, at least, a 'data' dict and a sound value."
            )

        given_pitch = data["data"].get("pitch")
        pitch: float = float(given_pitch if given_pitch is not None else DEFAULT_SOUND_PITCH)

        given_vol = data["data"].get("vol")
        vol: int = int(given_vol if given_vol is not None else DEFAULT_SOUND_VOL)
        return cls(SoundType(data["data"]["sound"]), pitch=pitch, volume=vol)

    def __repr__(self):
        return f"<{self.__class__.__name__} sound_type={self.sound_type.value} pitch={self.pitch} volume={self.volume}>"

    def __str__(self):
        return self.sound_type.value


@dataclass
class DFParticle:
    """
    Used for DF Particles (Smoke, Large Smoke etc.)

    `Attributes`:
    -------------
        `particle_type`: The ParticleType enum instance that specifies which particle is this.

    `Supported Comparisons`:
    ------------------------
        `a == b`: Checks if two particles have the same ParticleType enum value.

        `a != b`: Same as `not a == b`.
    """
    __slots__ = ("particle_type",)
    particle_type: ParticleType

    def set(self, particle_type: ParticleType) -> "DFParticle":
        """
        Immediately set the type of this DFParticle. Note that this is not changed dynamically, in DiamondFire. For
        that, use a dynamic variable.

        :param particle_type: The new particle type.
        :return: self to allow chaining
        """
        if not isinstance(particle_type, ParticleType):
            raise TypeError("Particle type must be an instance of ParticleType enum.")

        self.particle_type = particle_type

        return self

    def __post_init__(self):
        if not isinstance(self.particle_type, ParticleType):
            raise TypeError("Particle type must be an instance of ParticleType enum.")

    def to_item(self):
        pass  # TODO: Sparkly thing and stuff

    def as_json_data(self) -> dict:
        """
        Representation of this DFParticle as a valid json-serializable dict.

        :return: Dict
        """
        return dict(
            id=constants.ITEM_ID_PARTICLE,
            data=dict(
                particle=self.particle_type.value
            )
        )

    @classmethod
    def from_json_data(cls: typing.Type["DFParticle"], data: dict) -> "DFParticle":
        """
        Obtain DFParticle from pre-existing parsed JSON data.

        :param data: The parsed JSON dict.
        :return: DFParticle instance.
        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "particle" not in data["data"]
            or not type("particle") == str
        ):
            raise TypeError(
                "Malformed DFSound parsed JSON data! Must be a dict with, at least, a 'data' dict and a particle value."
            )

        return cls(ParticleType(data["data"]["particle"]))

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} particle_type={self.particle_type.value}>"

    def __str__(self) -> str:
        return str(self.particle_type.value)

    def __eq__(self, other: "DFParticle") -> bool:
        return type(self) == type(other) and self.particle_type == other.particle_type

    def __ne__(self, other: "DFParticle") -> bool:
        return not self.__eq__(other)


@dataclass
class DFCustomSpawnEgg:
    """
    Used for the custom spawn egg types provided by DiamondFire (Giant, Iron Golem etc.)

    `Attributes`:
    -------------
        `egg_type`: The CustomSpawnEggType enum instance that specifies which spawn egg is this.


    `Supported Comparisons`:
    -----------------------
        `a == b`: Checks if two `DFCustomSpawnEgg` instances have the same `egg_type` attribute.

        `a != b`: Same as `not a == b`
    """
    __slots__ = ("egg_type",)
    egg_type: CustomSpawnEggType

    def set(self, egg_type: CustomSpawnEggType) -> "DFCustomSpawnEgg":
        """
        Immediately set the type of this DFParticle. Note that this is not changed dynamically, in DiamondFire. For
        that, use a dynamic variable.

        :param egg_type: The new spawn egg type.
        :return: self to allow chaining
        """
        if not isinstance(egg_type, CustomSpawnEggType):
            raise TypeError("Egg type must be an instance of CustomSpawnEggType enum.")

        self.egg_type = egg_type

        return self

    def __post_init__(self):
        if not isinstance(self.egg_type, CustomSpawnEggType):
            raise TypeError("Egg type must be an instance of CustomSpawnEggType enum.")

    def to_item(self):
        pass  # TODO: egg lol

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} egg_type={self.egg_type.value}>"

    def __str__(self) -> str:
        return str(self.egg_type.value)

    def __eq__(self, other: "DFCustomSpawnEgg") -> bool:
        return type(self) == type(other) and self.egg_type == other.egg_type

    def __ne__(self, other: "DFCustomSpawnEgg") -> bool:
        return not self.__eq__(other)

    # TODO: Figure out json for Custom Spawn Egg;


class DFPotion:
    """
    Used for potion effects in potion-effect-related actions.

    `Attributes`:
    -------------
        `effect`: The PotionEffect enum instance that specifies which potion effect this DFPotion represents.

        `amplifier`: int representing the strength of the effect. This should vary between -255 and 255.

        `duration`: int x int tuple (int, int). Represents the duration of the effect in the form (min, seconds).

    `Supported Comparisons`:
    ------------------------
        `a == b`: Checks if two DFPotions have the same `effect`, `amplifier` and `duration` attributes.

        `a != b`: Same as `not a == b`

        `a > b`, `a >= b`, `a < b`, `a <= b`: Applies the respective comparisons on the amplifiers of the potions.

    `Supported Operations`:
    -----------------------
        `a + b`, `a - b`, `a * b`, `a / b`, `a // b`, `a % b`, `a ** b`: Applies the respective operations between the
        amplifiers of the potions, generating a new DFPotion (e.g. amplifier 5 pot - amplifier 2 pot = amplifier 3
        pot). Worth noting that those operations also work between one DFPotion and one int/float, however the result is
        always rounded down, since amplifiers can only be `int`s. (e.g. DFPotion(amp=5) + 6 => DFPotion(amp=11))

        `a += b`, `a -= b`, ...: Applies each of the operations above, in a similar fashion.

        `ceil(a)`, `floor(a)`, `abs(a)`, `+a`: Returns the class itself.

        `bool(a)`: Returns whether or not the duration is bigger than 00:00 (tuple > (0,0) ).
    """
    __slots__ = ("effect", "amplifier", "duration")

    effect: PotionEffect
    amplifier: int
    duration: typing.Tuple[int, int]

    def __init__(self, effect: PotionEffect, *, amplifier: int = 1, duration: typing.Iterable[int, int] = (0, 5)):
        """
        Init this DFPotion.

        :param effect: The effect that this DFPotion represents.
        :param amplifier: An amplifier int.
        :param duration: A duration in the form (int, int). Can be any Iterable with two ints.
        """
        self.effect = PotionEffect(effect)
        self.amplifier = int(amplifier)
        self.duration = typing.cast(typing.Tuple[int, int], tuple(map(int, duration))[:2])

    def set(
        self, effect: PotionEffect = DEFAULT_VAL,
        *, amplifier: int = DEFAULT_VAL, duration: typing.Iterable[int, int] = DEFAULT_VAL
    ) -> "DFPotion":
        """
        Set certain attributes of this DFPotion. Specify `constants.DEFAULT_VAL` to not change one.

        :param effect: The new potion effect.
        :param amplifier: The new amplifier.
        :param duration: The new duration/
        :return: self for chaining
        """
        if effect != DEFAULT_VAL:
            self.effect = PotionEffect(effect)

        if amplifier != DEFAULT_VAL:
            self.amplifier = int(amplifier)

        if duration != DEFAULT_VAL:
            self.duration = typing.cast(typing.Tuple[int, int], tuple(map(int, duration))[:2])

        return self

    def as_json_data(self) -> dict:
        """
        Returns this DFPotion as a valid json serializable dict.

        :return: Dict
        """
        return dict(
            id=constants.ITEM_ID_POTION,
            data=dict(
                pot=self.effect.value,
                dur=None,  # TODO: Figure out dur json; milliseconds?
                amp=self.amplifier
            )
        )

    def from_json_data(self) -> dict:
        pass  # TODO: Figure out dur json then implement this

    def copy(self) -> "DFPotion":
        """
        Creates an identical copy of this DFPotion.

        :return: Copy DFPotion.
        """
        return DFPotion(self.effect, amplifier=self.amplifier, duration=self.duration)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} effect={self.effect.value} amplifier={self.amplifier} \
duration={self.duration[0]}:{self.duration[1]}>"

    def __str__(self) -> str:
        return self.effect.value

    def __bool__(self) -> bool:
        """
        Returns whether or not this DFPotion's duration is higher than 00:00 (> (0,0)).
        :return: bool
        """
        return self.duration > (0, 0)

    def __eq__(self, other: "DFPotion") -> bool:
        """
        Checks if two DFPotions are strictly equal (have the same effect, amplifier and duration).

        :param other: DFPotion to compare.
        :return: Whether or not they are equal.
        """
        return type(self) == type(other) and self.effect == other.effect and self.amplifier == other.amplifier \
            and self.duration == other.duration

    def __ne__(self, other: "DFPotion") -> bool:
        return not self.__eq__(other)

    def __gt__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier > other.amplifier

    def __ge__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier >= other.amplifier

    def __lt__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier < other.amplifier

    def __le__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier <= other.amplifier

    def __add__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be added with another DFPotion of same effect, or with an int/float.")

        copy = self.copy()
        copy.amplifier += other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __radd__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        return self.__add__(other)

    def __mul__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be multiplied with another DFPotion of same effect, or with an int/float.")

        copy = self.copy()
        copy.amplifier *= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __rmul__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        return self.__mul__(other)

    def __sub__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier -= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __pow__(self, other: typing.Union["DFPotion", AnyNumber], modulo=None) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(
                f"DFPotion must be taken to the power of another DFPotion of same effect, or of an int/float."
            )

        copy = self.copy()
        copy.amplifier = int(pow(
            copy.amplifier, other.amplifier if isinstance(other, type(self)) else other,
            modulo
        ))
        return copy

    def __truediv__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier /= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __floordiv__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier //= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __mod__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier %= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __ceil__(self):
        return self

    def __floor__(self):
        return self

    def __pos__(self):
        return self

    def __abs__(self):
        return self


# TODO: GameValue


DFType = typing.Union[
    Item, DFText, DFNumber, DFLocation, DFSound, DFParticle, DFCustomSpawnEgg, DFPotion
]  # TODO: GameValue etc
