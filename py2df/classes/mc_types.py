import typing
import math
import re
import collections
import operator
import json
from .. import constants
from dataclasses import dataclass
from ..enums import Material, HideFlags, SoundType, ParticleType, CustomSpawnEggType, PotionEffect
from .subcollections import Lore
from .dataclass import Enchantment
from ..utils import nbt_dict_to_str, NBTWrapper, remove_u200b_from_doc
from ..constants import DEFAULT_VAL, DEFAULT_SOUND_PITCH, DEFAULT_SOUND_VOL


class Item:
    """Represents a Minecraft Item stack.
    
    Attributes\u200b
    -------------
    
        material : :class:`~py2df.enums.materials.Material`
            Tells what kind of item this is.
    
        amount : :class:`int`
            The amount there is in this Item stack. (From 1 to 64 - any number outside those bounds will error!)
    
        name : :class:`str`
            The item's name.
    
        lore : :class:`~py2df.classes.subcollections.Lore`
            The item's lore, as an instance of Lore.
    
        enchantments : List[:class:`~py2df.classes.dataclass.Enchantment`]
            A list containing instances of Enchantment.
    
        damage : :class:`int`
            How broken this item is (0 = not broken at all; the higher, the closer to breaking it is). The max
            amount this attribute can have depends on the item's durability, for which there are many lists online.
    
        unbreakable : :class:`bool`
            If True, this item cannot lose durability, and remains at damage = 0.
    
        hide_flags : :class:`~py2df.enums.misc_mc_enums.HideFlags`
            Flags to be hidden. Use the HideFlags enum for this. One flag is of the form HideFlag.FLAG_NAME,
            while, to use more than one, add them up (HideFlag.FLAG_NAME + HideFlag.OTHER_FLAG_NAME + ...). There is also
            HideFlag.ALL which has all flags added up already for you. So, you can select to hide "all but FLAG_NAME" by
            using subtraction: HideFlag.ALL - HideFlag.FLAG_NAME (generically speaking).
    
        leather_armor_color : :class:`int`
            An integer that represents the color of a leather armor. Tip: write `0x......` for a
            hexadecimal representation. (This is not present in non-leather armor items.)
    
        entity_tag : Optional[Union[:class:`str`, :class:`dict`]]
            :class:`str`, :class:`dict` or None (depending on what is given by the user) of NBT. Any NBT that
            modifies entities generated by either spawn eggs, the armor stand item or tropical fish buckets.
            (For other :class:`Material`s, this attribute should always be None.)
    
        extra_tags : Optional[Union[:class:`str`, :class:`dict`]]
            :class:`str`, :class:`dict` or None of NBT, representing any extra tags not covered here.
    """
    __slots__ = (
        "material", "_amount", "name", "lore", "enchantments", "damage", "unbreakable", "hide_flags",
        "leather_armor_color", "entity_tag", "extra_tags"
    )

    def __init__(
            self, material: Material, amount: int = 1,
            *, name: typing.Optional[typing.Union[str, "DFText"]] = None,
            lore: typing.Union[Lore, typing.Optional[typing.Iterable[str]]] = Lore(),
            enchantments: typing.Optional[typing.Iterable[Enchantment]] = None,
            damage: int = 0, unbreakable: bool = False, hide_flags: typing.Optional[HideFlags] = None,
            leather_armor_color: typing.Optional[int] = None,
            entity_tag: typing.Optional[typing.Union[dict, str]] = None,
            extra_tags: typing.Optional[typing.Union[dict, str]] = None
    ):
        """Initialize the item stack.

        Parameters
        ----------

        material : :class:`Material`
            Instance of the Materials enum; represents what this item actually is.

        amount : :class:`int`
            The amount of items in this item stack, between 1 and 64. By default, 1.

        name : Optional[Union[:class:`str`, :class:`DFText`]]
            An optional custom name to be given to this item, as a `:class:`str`` or :class:`DFText`. Default: None

        lore : Union[`Lore`, Optional[Iterable[:class:`str`]]]
            A Lore for this item (either Lore instance or list of `:class:`str``). Default: empty Lore instance.

        enchantments : Optional[Iterable[:class:`~py2df.classes.dataclass.Enchantment`]]
            A list of :class:`~py2df.classes.dataclass.Enchantment` instances.

        damage : :class:`int`
            The damage of this item (i.e., amount of uses so far). Defaults to 0 (not used).

        unbreakable : :class:`bool`
            Whether or not this item is unbreakable. Defaults to False.

        hide_flags : Optional[:class:`~py2df.enums.misc_mc_enums.HideFlags`]
            Flags to be hidden, such as unbreakability. See the enum documentation for more info.

        Other Parameters
        ----------------
        leather_armor_color : Optional[:class:`int`]
            If this is a piece of leather armor, specify its color through an integer. Tip: Use
            ``0x......`` for hexadecimal colors.

        entity_tag : Optional[Union[:class:`dict`, :class:`str`]]
            An optional :class:`str` or :class:`dict` representing Entity NBT tags applied on entities that are spawned
            through this item. Applies to the materials: (X)_SPAWN_EGG; TROPICAL_FISH_BUCKET; ARMOR_STAND. Default:
            None

        extra_tags : Optional[Union[:class:`dict`, :class:`str`]]
            Any extra NBT tags you'd like to give your item, either as a :class:`dict` of NBT tags or a valid NBT
            :class:`str`. Please ensure those tags do not conflict with the previous ones to avoid spooky errors in
            DiamondFire. Default: ``None``.
            (Please ensure this is a valid TAG_Compound in NBT, a.k.a. `:class:`dict` in pythonic language.)
        """
        self.material: Material = material
        self._amount: int = 1
        self.amount = amount
        self.name: str = str(name)
        self.lore: Lore = Lore(lore)

        if enchantments and any(type(i) != Enchantment for i in enchantments):
            raise TypeError("Non-Enchantment instance found in given 'enchantments' arg.")

        self.enchantments = list(enchantments) if enchantments else []

        self.damage: int = int(damage)

        self.unbreakable: bool = bool(unbreakable)

        self.hide_flags: HideFlags = hide_flags

        if self.material in (
            Material.LEATHER_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS
        ):
            self.leather_armor_color: typing.Optional[int] = int(leather_armor_color) \
                if leather_armor_color is not None else None
        else:
            self.leather_armor_color: typing.Optional[int] = None

        if "SPAWN_EGG" in self.material.value.upper() or self.material in (
            Material.ARMOR_STAND, Material.TROPICAL_FISH_BUCKET
        ):
            self.entity_tag: typing.Optional[typing.Union[dict, str]] = entity_tag
        else:
            self.entity_tag: typing.Optional[typing.Union[dict, str]] = None

        self.extra_tags = extra_tags

    @property
    def amount(self) -> int:
        return self._amount

    @amount.setter
    def amount(self, new_amt: int) -> None:
        i_n_amt = int(new_amt)
        if i_n_amt > constants.MAX_ITEM_STACK_SIZE:
            raise ValueError(f"Maximum item stack size is {constants.MAX_ITEM_STACK_SIZE}!")

        if i_n_amt < constants.MIN_ITEM_STACK_SIZE:
            raise ValueError(f"Minimum item stack size is {constants.MIN_ITEM_STACK_SIZE}!")

        self._amount = i_n_amt

    def as_nbt(self) -> str:
        """Returns this item as a NBT string.

        Returns
        -------
        :class:`str`
            SBNT string.
        """
        tag_dict = dict(
            *(dict(Damage=int(self.damage)) if self.damage != 0 else dict()),
            *(dict(Unbreakable=NBTWrapper("1b")) if self.unbreakable else dict()),  # NBTWrapper is used to ensure
            *(dict(                                                                 # quotes aren't used
                EntityTag=(
                    nbt_dict_to_str(self.entity_tag) if type(self.entity_tag) == dict else NBTWrapper(self.entity_tag)
                ) if self.entity_tag else dict()
            )),
            *(dict(
                display=dict(
                    *(dict(color=self.leather_armor_color) if self.leather_armor_color is not None else dict()),
                    *(dict(Name=json.dumps(str(self.name))) if self.name else dict()),
                    *(dict(Lore=self.lore.as_json_data() if self.lore else dict()))
                ) if any([self.leather_armor_color is not None, self.name, self.lore]) else dict()
            )),
            *(dict(HideFlags=self.hide_flags.value) if self.hide_flags and self.hide_flags.value else dict())
        )
        if type(self.extra_tags) == str:
            tag_dict["extra_tags"] = NBTWrapper(self.extra_tags)

        elif type(self.extra_tags) == dict:
            tag_dict.update(self.extra_tags)

        dict_with_data = dict(
            id=f"minecraft:{self.material.value}",
            Count=NBTWrapper(f"{min(max(self.amount, 1), 64)}b"),  # TODO: Finish this NBT
            tag=tag_dict
        )

        return nbt_dict_to_str(dict_with_data)

    def as_json_data(self) -> dict:
        """Returns this item as valid DF json representation (as a :class:`dict`, not as a string).

        Returns
        -------
        :class:`dict`
        """
        return dict(
            id=constants.ITEM_ID_ITEM,
            data=dict(
                item=self.as_nbt()  # it seems "DF_NBT = 1976" is just a means of representing version; can be ignored.
            )
        )

    # def from_json_data(self) -> "Item":
    #     pass  # TODO - ok now, this will be hard... gotta interpret NBT

    def to_item(self) -> "Item":
        return self  # well... yeah

    def set(self, material: Material = DEFAULT_VAL, *args, **kwargs) -> None:
        """Refer to __init__'s documentation.

        Parameters
        ----------
        material : :class:`~py2df.enums.Material`
             This item's material.
        *args :
            
        **kwargs :
            

        Returns
        -------
        None
            None

        Warnings
        --------
        This function is not done yet.
        """
        # TODO: finish
        pass

    def copy(self) -> "Item":
        """Makes an identical copy of this item stack.

        Returns
        -------
        :class:`Item`

        """
        return Item(
            self.material, self.amount, lore=self.lore, enchantments=self.enchantments, damage=self.damage,
            unbreakable=self.unbreakable, leather_armor_color=self.leather_armor_color, entity_tag=self.entity_tag,
            extra_tags=self.extra_tags
        )

    def __repr__(self):
        return f"<{self.__class__.__name__} minecraft:{self.material.value} x {self.amount}>"

    def __str__(self):
        return f"minecraft:{self.material.value}"

    def __eq__(self, other: "Item"):
        attrs_to_compare = set(self.__class__.__slots__) - {"_amount", }  # compare all except amount

        return type(self) == type(other) and all(
            getattr(self, attr) == getattr(other, attr) for attr in attrs_to_compare
        )

    def __ne__(self, other: "Item"):
        return not self.__eq__(other)

    def __gt__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount > other._amount

    def __ge__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount >= other._amount

    def __lt__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount < other._amount

    def __le__(self, other: "Item"):
        if self != other:
            raise TypeError("Cannot compare different items (must be equal)")

        return self._amount <= other._amount

    def __mul__(self, other: typing.Union[int, "Item"]):  # can be an Item if it is == to current instance.
        new = self.copy()
        new.amount *= other._amount if self == other else other
        return new

    def __rmul__(self, other: typing.Union[int, "Item"]):
        return self.__mul__(other)

    def __add__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount += other._amount if self == other else other
        return new

    def __radd__(self, other: typing.Union[int, "Item"]):
        return self.__add__(other)

    def __pow__(self, power: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount **= power._amount if self == power else power
        return new

    def __truediv__(self, other: typing.Union[int, "Item"]):  # always rounded.
        return self.__floordiv__(other)

    def __floordiv__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount //= other._amount if self == other else other
        return new

    def __sub__(self, other: typing.Union[int, "Item"]):
        new = self.copy()
        new.amount -= other._amount if self == other else other
        return new

    def __ceil__(self):
        return self

    def __floor__(self):
        return self

    def __abs__(self):
        return self

    def __pos__(self):
        return self


class DFText(collections.UserString):
    """Represents a DiamondFire Text variable. (note: this is not a dynamic variable.)
    
    Subclasses `collections.UserString`; therefore, supports all :class:`str` operations.
    
    Attributes
    ----------\u200b
        data : :class:`str`
            The value of the text variable.
    
        convert_color : :class:`bool`
            Whether or not should convert "&" to "§" (section sign) to allow easier color code writing.
            Defaults to True.

    """
    __slots__ = ("convert_color",)
    convert_color: bool

    def __init__(self, text: str = "", *, convert_color: bool = True):
        """
        Init text variable.

        Parameters
        ----------
        text : :class:`str`
            Text, defaults to "" (empty :class:`str`).
        convert_color : :class:`bool`
            Boolean; whether or not should convert &x to color codes (§x). (Defaults to True)
        """
        super().__init__(text)
        self.data = text
        self.convert_color = bool(convert_color)

    def set(self, new_text: str) -> "DFText":
        """Set the value of this text variable.

        Parameters
        ----------
        new_text : :class:`str`
            The new text.

        Returns
        -------
        :class:`DFText`
            self to allow chaining

        """
        self.data = new_text

        return self

    def as_json_data(self) -> dict:
        """Obtain this variable represented as a JSON object (:class:`dict`).

        Parameters
        ----------

        Returns
        -------
        :class:`dict`
        """
        converted_str: str = re.sub(
            constants.STR_COLOR_CODE_REGEX, constants.SECTION_SIGN + r"\1", self.data
        ) if self.convert_color else self.data  # convert color

        return dict(
            id=constants.ITEM_ID_TEXT_VAR,
            data=dict(
                name=converted_str
            )
        )

    @classmethod
    def from_json_data(cls, data: dict):
        """Obtain variable from pre-existing parsed JSON data.

        Parameters
        ----------
        data : :class:`dict`
            The parsed JSON :class:`dict`.
            

        Returns
        -------
        :class:`DFText`
            :class:`DFText` instance.

        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "name" not in data["data"]
            or not type("name") == str
        ):
            raise TypeError(
                "Malformed DFText parsed JSON data! Must be a dict with, at least, a 'data' dict and a name str value."
            )

        return cls(data["data"]["name"])

    def to_item(self) -> Item:
        pass  # TODO: implement this as book and stuff

    def __repr__(self):
        return f"<{self.__class__.__name__} data='{self.data}'>"


AnyNumber = typing.Union[int, float]


class DFNumber:
    """Represents a DiamondFire Number variable.
    
    Supports practically all :class:`int`/:class:`float`-related operations and comparisons.
    
    Attributes\u200b
    ------------
        value : :class:`float`
            The value of the number variable.
    """
    __slots__ = ("_value",)
    _value: float

    def __init__(self, value: AnyNumber = 0.0):
        """
        Init number variable.

        Parameters
        ----------
            value : Union[:class:`int`, :class:`float`]
                Value of this :class:`DFNumber`. Defaults to ``0.0``
        """
        self.value = value

    @property
    def value(self) -> float:
        """The value of this number variable.

        Returns
        -------
        :class:`float`
        """
        return self._value

    @value.setter
    def value(self, new_value: AnyNumber):
        """Set the value of this number variable.

        Parameters
        ----------
        new_value : Union[:class:`int`, :class:`float`]
            The new value.

        """
        self._value = float(new_value)

    def set(self, new_value: AnyNumber) -> "DFNumber":
        """Set the value of this number variable.

        Parameters
        ----------
        new_value : Union[:class:`int`, :class:`float`]
            The new value.

        Returns
        -------
        :class:`DFNumber`
            self to allow chaining
        """
        self._value = float(new_value)

        return self

    def as_json_data(self) -> dict:
        """Obtain this variable represented as a JSON object (:class:`dict`)."""
        return dict(
            id=constants.ITEM_ID_NUMBER_VAR,
            data=dict(
                name=str(self.value)
            )
        )

    @classmethod
    def from_json_data(cls, data: dict) -> "DFNumber":
        """Obtain variable from pre-existing parsed JSON data.

        Parameters
        ----------
        data : :class:`dict`
            The parsed JSON :class:`dict`.
            

        Returns
        -------
        :class:`DFNumber`
            :class:`DFNumber` instance.

        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "name" not in data["data"]
            or not type("name") in (int, float, str)
        ):
            raise TypeError(
                "Malformed DFNumber parsed JSON data! Must be a dict with, at least, a 'data' dict and a name value."
            )

        return cls(float(data["data"]["name"]))

    def copy(self) -> "DFNumber":
        """
        Obtain an identical copy of this :class:`DFNumber` instance.

        Returns
        -------
        :class:`DFNumber`
            Identical copy of this instance.
        """
        return DFNumber(self.value)

    def to_item(self) -> Item:
        pass  # TODO: implement this as slimeball and stuff

    @staticmethod
    def _extract_val(possible_num: typing.Union[int, float, "DFNumber"]):
        if isinstance(possible_num, DFNumber):
            return possible_num.value

        return possible_num

    def __repr__(self):
        return f"<{self.__class__.__name__} value={self.value}>"

    def __str__(self):
        return str(self.value)

    def __eq__(self, other):
        return type(self) == type(other) and self.value == other.value

    def __ne__(self, other):
        return not self.__eq__(other)

    def __gt__(self, other):
        return self.value > DFNumber._extract_val(other)

    def __ge__(self, other):
        return self.value >= DFNumber._extract_val(other)

    def __lt__(self, other):
        return self.value < DFNumber._extract_val(other)

    def __le__(self, other):
        return self.value <= DFNumber._extract_val(other)

    def __add__(self, other):
        return DFNumber(self.value + DFNumber._extract_val(other))

    def __radd__(self, other):
        return self.__add__(other)

    def __sub__(self, other):
        return DFNumber(self.value - DFNumber._extract_val(other))

    def __rsub__(self, other):
        return DFNumber((+other) - self.value)

    def __mul__(self, other):
        return DFNumber(self.value * DFNumber._extract_val(other))

    def __rmul__(self, other):
        return self.__mul__(other)

    def __mod__(self, other):
        return DFNumber(self.value % DFNumber._extract_val(other))

    def __rmod__(self, other):
        return other % self.value

    def __truediv__(self, other):
        return DFNumber(self.value / DFNumber._extract_val(other))

    def __floordiv__(self, other):
        return DFNumber(self.value // DFNumber._extract_val(other))

    def __pow__(self, power):
        return DFNumber(self.value ** DFNumber._extract_val(power))

    def __neg__(self):
        return DFNumber(-self.value)

    def __pos__(self):
        return self

    def __abs__(self):
        return DFNumber(abs(self.value))

    def __ceil__(self):
        return DFNumber(math.ceil(self.value))

    def __floor__(self):
        return DFNumber(math.floor(self.value))

    def __bool__(self):
        return self.value != 0.0

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)


class DFLocation:
    """Represents a DiamondFire Location.
    
    Attributes\u200b
    -------------
    
        x : :class:`float`
            The value of the x position.
    
        y : :class:`float`
            The value of the y position.
    
        z : :class:`float`
            The value of the z position.
    
        pitch : :class:`float`
            The pitch value.
    
        yaw : :class:`float`
            The yaw value.
    
        is_block : :class:`bool`
            Whether or not this location represents a solid (non-air) block. Defaults to False.
    
    **Supported comparisons:**
    
        ``a == b``: True if `a` and `b` have the same x,y,z,pitch,yaw, False if at least one is different.
    
        ``a != b``: Negation of ``a == b``.
    
        ``a > b``: True if at least one of the coordinates x,y,z of a is bigger than the respective coordinate in b;
        False otherwise.
    
        ``a < b``: True if at least one of the coordinates x,y,z of a is smaller than the respective coordinate in b;
        False otherwise.
    
        ``a >= b``: Applies ``>=`` between each coordinate x,y,z of `a` and `b`.
    
        ``a <= b``: Applies ``<=`` between each coordinate x,y,z of `a` and `b`.
    
    
    **Supported operations:**
    
        (Note: They are all applied in-place with given values, not dynamically in DiamondFire!)
    
        ``a + b``: Adds two locations' x, y, z; pitch, yaw (mod 360 degrees). If `b` is an iterable (tuple, list etc.),
        then the respective items 0-4 are added as x,y,z;pitch,yaw.
        If `b` is an :class:`int`/:class:`float`, it is added to x,y,z.
    
        ``a - b``: Follows same rules as addition, except that it is a subtraction.
    
        ``a * b``: Again, same rules as addition, but multiplication.
    
        ``a / b``: Same rules as addition, but division.
    
        ``a // b``: Same rules as division, but floors.
    
        ``a ** b``: Same rules as addition, but as exponentiation.
    
        ``-a``: Applies -1 times x,y,z; pitch, yaw of `a`.
    
        ``:func:`abs`(a)``: Applies abs() to x,y,z,pitch,yaw of `a`.
    
        ``+a``: Returns a.
    """
    __slots__ = ("x", "y", "z", "pitch", "yaw", "is_block")  # , "world_least", "world_most")

    x: float
    y: float
    z: float
    pitch: float
    yaw: float
    is_block: bool
    # world_least: typing.Optional[:class:`int`]
    # world_most: typing.Optional[:class:`int`]

    def __init__(
        self, x: AnyNumber = 0.0, y: AnyNumber = 0.0, z: AnyNumber = 0.0, pitch: AnyNumber = 0.0,
        yaw: AnyNumber = 0.0,
        *, is_block: bool = False,
        # world_least: typing.Optional[:class:`int`] = None, world_most: typing.Optional[:class:`int`] = None
        # locs are now relative
    ):
        """
        Init the location.

        Parameters
        ----------
        x : Union[:class:`int`, :class:`float`]
            The value of the x position (:class:`float`).


        y : Union[:class:`int`, :class:`float`]
            The value of the y position (:class:`float`).

        z : Union[:class:`int`, :class:`float`]
            The value of the z position (:class:`float`).

        pitch : Union[:class:`int`, :class:`float`]
            The pitch value (:class:`float`).

        yaw : Union[:class:`int`, :class:`float`]
            The yaw value (:class:`float`).

        is_block : :class:`bool`
            Whether or not this location represents a solid (non-air) block. (:class:`bool`) Defaults to False.
        """
        # :param world_least: A constant :class:`int` related to DF; this shouldn't need to be defined by the
        #   library user. None to let the library handle it.
        # :param world_most: A constant :class:`int` related to DF; this shouldn't need to be defined by the
        # library user. None to let the library handle it.
        self.x = float(x)
        self.y = float(y)
        self.z = float(z)
        self.pitch = float(pitch)
        self.yaw = float(yaw)
        self.is_block = bool(is_block)
        # self.world_least = None if world_least is None else :class:`int`(world_least)
        # self.world_most = None if world_most is None else :class:`int`(world_most)

    def set(
        self, x: AnyNumber = DEFAULT_VAL, y: AnyNumber = DEFAULT_VAL, z: AnyNumber = DEFAULT_VAL,
        pitch: AnyNumber = DEFAULT_VAL, yaw: AnyNumber = DEFAULT_VAL,
        *, is_block: bool = DEFAULT_VAL,
        # world_least: typing.Optional[:class:`int`] = DEFAULT_VAL, world_most: typing.Optional[:class:`int`] \
        # = DEFAULT_VAL
    ) -> "DFLocation":
        """Set the location.

        Parameters
        ----------
        x : Union[:class:`int`, :class:`float`], optional
            The value of the x position (:class:`float`).

        y : Union[:class:`int`, :class:`float`], optional
            The value of the y position (:class:`float`).

        z : Union[:class:`int`, :class:`float`], optional
            The value of the z position (:class:`float`).

        pitch : Union[:class:`int`, :class:`float`], optional
            The pitch value (:class:`float`).

        yaw : Union[:class:`int`, :class:`float`], optional
            The yaw value (:class:`float`).

        is_block : :class:`bool`, optional
            Whether or not this location represents a solid (non-air) block. (:class:`bool`) Defaults to False.

        Returns
        -------
        :class:`DFLocation`
            self to allow chaining

        Notes
        -----
        All parameters are optional here, meaning that one can pass :const:`~py2df.constants.utility_consts.DEFAULT_VAL`
        to omit a parameter - or, more simply, only use kwargs to choose which values to set.

        Warnings
        --------
        Passing ``None`` will set the value to that! If your intention is to omit a parameter, use
        :const:`~py2df.constants.utility_consts.DEFAULT_VAL` or simply use kwargs to choose which values to set.
        """
        # :param world_least: A constant :class:`int` related to DF; this shouldn't need to be defined by
        # the library user. None to let the library handle it.
        # :param world_most: A constant :class:`int` related to DF; this shouldn't need to be defined by
        # the library user. None to let the library handle it

        self.x = self.x if x == DEFAULT_VAL else float(x)
        self.y = self.y if y == DEFAULT_VAL else float(y)
        self.z = self.z if z == DEFAULT_VAL else float(z)
        self.pitch = self.pitch if pitch == DEFAULT_VAL else float(pitch)
        self.yaw = self.yaw if yaw == DEFAULT_VAL else float(yaw)
        self.is_block = self.is_block if is_block == DEFAULT_VAL else bool(is_block)
        # self.world_least = self.world_least if world_least == DEFAULT_VAL else (
        #     None if world_least is None else :class:`int`(world_least)
        # )
        # self.world_least = self.world_most if world_most == DEFAULT_VAL else (
        #     None if world_most is None else :class:`int`(world_most)
        # )

        return self

    def set_to_other(self, loc: "DFLocation") -> "DFLocation":
        """Imports another location's values into this one, making it identical.

        Parameters
        ----------
        loc : :class:`DFLocation`
            Other location to set.

        Returns
        -------
        :class:`DFLocation`
            `self` to allow chaining

        """
        return self.set(
            loc.x, loc.y, loc.z, loc.pitch, loc.yaw, is_block=loc.is_block,
            # world_least=loc.world_least, world_most=loc.world_most
        )

    def as_json_data(self) -> dict:
        """Obtain this location represented as a JSON object (:class:`dict`).

        Returns
        -------
        :class:`dict`
        """
        return dict(
            id=constants.ITEM_ID_LOCATION,
            data=dict(
                isBlock=self.is_block,
                x=self.x,
                y=self.y,
                z=self.z,
                pitch=self.pitch,
                yaw=self.yaw
            )
        )

    @classmethod
    def from_json_data(cls, data: dict) -> "DFLocation":
        """Obtain variable from pre-existing parsed JSON data.

        Parameters
        ----------
        data : :class:`dict`
            The parsed JSON :class:`dict`.

        Returns
        -------
        :class:`DFLocation`
            :class:`DFNumber` instance.

        """
        required_attrs = ("x", "y", "z", "isBlock", "pitch", "yaw", "worldLeast", "worldMost")
        if (
                not isinstance(data, dict)
                # or "id" not in data
                or "data" not in data
                or not isinstance(data["data"], dict)
                or not all(attr in data["data"] for attr in required_attrs)
        ):
            raise TypeError(
                f"Malformed DFLocation parsed JSON data! Must be a dict with a 'data' dict including the \
                following attributes: {', '.join(required_attrs)}."
            )

        d_dict = data["data"]

        return cls(
            d_dict.x, d_dict.y, d_dict.z, d_dict.pitch, d_dict.yaw,
            is_block=d_dict.isBlock
        )

    def copy(self) -> "DFLocation":
        """Creates an identical copy of this location.

        Returns
        -------
        :class:`DFLocation`
            Copied location.
        """
        new_loc = DFLocation()
        new_loc.set_to_other(self)
        return new_loc

    def _exec_arithmetic(
        self, other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ], arithmetic: typing.Callable, *, op_name: str
    ):
        """Executes some arithmetic within the Location and returns a new one.

        Parameters
        ----------
        other : Union[:class:`DFLocation`, Optional[Iterable[Union[:class:`int`, :class:`float`]], \
`Union`[`:class:`int``, `:class:`float``]]
            The other :class:`DFLocation`, an iterable of the form (x,y,z,pitch,yaw) (use None on any spot to keep
            unchanged), or a :class:`float` that is distributed upon x,y,z.
        arithmetic : `Callable`
            The function that executes the operation.
        op_name : `:class:`str``
            The operation name, to be used in the Error message.

        Returns
        -------
        :class:`DFLocation`
            New :class:`DFLocation`.

        Raises
        ------
        TypeError
            Invalid type provided for arithmetic.

        """
        new_loc = self.copy()

        if type(other) == DFLocation:
            x, y, z, pitch, yaw = map(float, (other.x, other.y, other.z, other.pitch, other.yaw))

        elif isinstance(other, collections.Iterable):
            attr_list = [None] * 5  # initialize an empty array
            for i, value in enumerate(other):
                if i > len(attr_list) - 1:
                    break  # we don't need more values.

                attr_list[i] = value

            x, y, z, pitch, yaw = attr_list

        elif type(other) in (int, float):
            num = float(other)
            x, y, z = [num] * 3
            pitch, yaw = [None] * 2

        else:
            raise TypeError(f"Invalid type for DFLocation {op_name}: {type(other)}!")

        for attr, val in zip(("x", "y", "z"), (x, y, z)):
            if val is None:
                continue  # keep current value

            old_val = getattr(new_loc, attr)

            if op_name == "division" and old_val == val == 0:
                continue  # nope; division by zero

            setattr(new_loc, attr, float(arithmetic(float(old_val), float(val))))

        for mod_attr, val in zip(("pitch", "yaw"), (pitch, yaw)):  # gotta do this mod 360, they're rotation values.
            if val is None:
                continue  # keep current value

            old_val = getattr(new_loc, mod_attr)

            if op_name == "division" and old_val == val == 0:
                continue  # nope; division by zero

            result_val = float(
                arithmetic(float(old_val), float(val))
            )
            setattr(
                new_loc, mod_attr, math.copysign(abs(result_val) % constants.MAX_DEGREES, result_val)
            )                                                       # mod 360 degrees, while keeping the sign (- or +).

        return new_loc

    def __eq__(self, other: "DFLocation") -> bool:
        attrs_to_check = set(self.__class__.__slots__)  # - {"world_least", "world_most"}
        return type(self) == type(other) and all(getattr(self, attr) == getattr(other, attr) for attr in attrs_to_check)

    def __ne__(self, other: "DFLocation"):
        return not self.__eq__(other)

    def __gt__(self, other: "DFLocation") -> bool:
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return any(getattr(self, attr) > getattr(other, attr) for attr in positional_attrs)

    def __ge__(self, other: "DFLocation") -> bool:
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return all(getattr(self, attr) >= getattr(other, attr) for attr in positional_attrs)

    def __lt__(self, other: "DFLocation") -> bool:
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return any(getattr(self, attr) < getattr(other, attr) for attr in positional_attrs)

    def __le__(self, other: "DFLocation") -> bool:
        if not isinstance(other, type(self)):
            raise TypeError(f"Incompatible comparison types {type(self)} and {type(other)}.")

        positional_attrs = ("x", "y", "z")
        return all(getattr(self, attr) <= getattr(other, attr) for attr in positional_attrs)

    def __repr__(self):
        return f"<{self.__class__.__name__} x={self.x} y={self.y} z={self.z} pitch={self.pitch} yaw={self.yaw}>"

    def __str__(self):
        return str((self.x, self.y, self.z, self.pitch, self.yaw))

    def __getitem__(self, item: typing.Union[int, str, slice]):
        if item in self.__class__.__slots__:  # ["x"]
            return getattr(self, item)  # give them self.x

        positional_attrs = (self.x, self.y, self.z)
        return positional_attrs[item]  # [0] = x ; [1] = y ; [2] = z

    def __setitem__(self, key: typing.Union[int, str, slice], value: typing.Union[int, float]):
        fl_val = float(value)
        if key in self.__class__.__slots__:
            return setattr(self, key, fl_val)

        pos_attrs = ("x", "y", "z")
        attr_s_to_set = pos_attrs[key]
        if type(attr_s_to_set) == str:
            setattr(self, attr_s_to_set, fl_val)
        else:
            for attr_name in attr_s_to_set:
                setattr(self, attr_name, fl_val)

    def __iter__(self):
        for coord in (self.x, self.y, self.z):
            yield coord

    def __add__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, operator.add, op_name="addition")

    def __radd__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self.__add__(other)

    def __sub__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, operator.sub, op_name="subtraction")

    def __rsub__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return DFLocation.__add__(-self, other)

    def __mul__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
            ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, operator.mul, op_name="multiplication")

    def __rmul__(
            self,
            other: typing.Union[
                "DFLocation",
                typing.Optional[typing.Iterable[AnyNumber]],
                AnyNumber
            ]
    ) -> "DFLocation":
        return self.__mul__(other)

    def __truediv__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, operator.truediv, op_name="division")

    def __floordiv__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
        ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, operator.floordiv, op_name="division")

    def __pow__(
        self,
        other: typing.Union[
            "DFLocation",
            typing.Optional[typing.Iterable[AnyNumber]],
            AnyNumber
            ]
    ) -> "DFLocation":
        return self._exec_arithmetic(other, pow, op_name="power")

    def __neg__(self):
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, -1 * (getattr(self, attr)))

        return new_loc

    def __pos__(self):
        return self

    def __abs__(self):
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, abs(getattr(self, attr)))

        return new_loc

    def __ceil__(self):
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, float(math.ceil(getattr(self, attr))))

        return new_loc

    def __floor__(self):
        new_loc = self.copy()
        for attr in ("x", "y", "z", "pitch", "yaw"):
            setattr(new_loc, attr, float(math.floor(getattr(self, attr))))

        return new_loc


class DFSound:
    """Used for DF Sounds (Blaze Death, XP Level up etc.)
    
    Attributes\u200b
    -------------
    
        sound_type : :class:`SoundType`
            The enum instance that specifies which sound is this.

        pitch : :class:`float`
            The pitch of this sound. Defaults to 1.0

        volume : :class:`int`
            The volume of this sound. Defaults to 2

    """
    __slots__ = ("sound_type", "pitch", "volume")
    sound_type: SoundType
    pitch: float
    volume: int

    def __init__(
        self, sound_type: SoundType, *, volume: int = DEFAULT_SOUND_VOL,
        pitch: AnyNumber = DEFAULT_SOUND_PITCH
    ):
        if not isinstance(sound_type, SoundType):
            raise TypeError("Sound type must be an instance of SoundType enum.")

        self.sound_type: SoundType = sound_type
        self.pitch: float = float(pitch)
        self.volume: int = int(volume)

    def set(
        self, sound_type: SoundType = DEFAULT_VAL, pitch: AnyNumber = DEFAULT_VAL, volume: int = DEFAULT_VAL
    ) -> "DFSound":
        """Immediately modify this :class:`DFSound`. Note that this is not changed dynamically, in DiamondFire.
        For that, use a dynamic variable.

        Parameters
        ----------
        sound_type : :class:`SoundType`
            The new sound type. (Can be omitted)
            (Default value = DEFAULT_VAL)
        pitch : Union[:class:`int`, :class:`float`]
            The new sound pitch. (Can be omitted)
            (Default value = DEFAULT_VAL)
        volume : :class:`int`
            The new volume. (Can be omitted)
            (Default value = DEFAULT_VAL)

        Returns
        -------
        :class:`DFSound`
            self to allow chaining
        """
        if not isinstance(sound_type, SoundType) and sound_type != DEFAULT_VAL:
            raise TypeError("Sound type must be an instance of SoundType enum.")

        self.sound_type = self.sound_type if sound_type == DEFAULT_VAL else sound_type
        self.pitch = float(self.pitch if pitch == DEFAULT_VAL else pitch)
        self.volume = int(self.volume if volume == DEFAULT_VAL else volume)
        return self

    def set_to_other(self, other: "DFSound") -> "DFSound":
        """
        Set this instance to become identical to another :class:`DFSound` instance.
        
        Parameters
        ----------
        other : :class:`DFSound`
            Other sound to set this instance to.

        Returns
        -------
        :class:`DFSound`
            self to allow chaining
        """
        self.set(sound_type=other.sound_type, pitch=other.pitch, volume=other.volume)
        return self

    def to_item(self) -> "Item":
        pass  # TODO: Sea shell and crap

    def copy(self) -> "DFSound":
        """
        Creates an identical copy of this :class:`DFSound` instance.

        Returns
        -------
        :class:`DFSound`
            Copy of this sound.
        """
        return DFSound(sound_type=self.sound_type, pitch=self.pitch, volume=self.volume)

    def as_json_data(self) -> dict:
        """Representation of this :class:`DFSound` as a valid json-serializable :class:`dict`.

        Returns
        -------
        :class:`dict`
            JSON-serializable :class:`dict`
        """
        return dict(
            id=constants.ITEM_ID_SOUND,
            data=dict(
                sound=self.sound_type.value,
                pitch=float(self.pitch),
                vol=int(self.volume)
            )
        )

    @classmethod
    def from_json_data(cls: typing.Type["DFSound"], data: dict) -> "DFSound":
        """Obtain :class:`DFSound` from pre-existing parsed JSON data.

        Parameters
        ----------
        data : :class:`dict`
            The parsed JSON :class:`dict`.

        Returns
        -------
        :class:`DFSound`
            New :class:`DFSound` instance.

        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "sound" not in data["data"]
            or not type("sound") == str
        ):
            raise TypeError(
                "Malformed DFSound parsed JSON data! Must be a dict with, at least, a 'data' dict and a sound value."
            )

        given_pitch = data["data"].get("pitch")
        pitch: float = float(given_pitch if given_pitch is not None else DEFAULT_SOUND_PITCH)

        given_vol = data["data"].get("vol")
        vol: int = int(given_vol if given_vol is not None else DEFAULT_SOUND_VOL)
        return cls(SoundType(data["data"]["sound"]), pitch=pitch, volume=vol)

    def __repr__(self):
        return f"<{self.__class__.__name__} sound_type={self.sound_type.value} pitch={self.pitch} volume={self.volume}>"

    def __str__(self):
        return self.sound_type.value


@dataclass
class DFParticle:
    """Used for DF Particles (Smoke, Large Smoke etc.)
    
    Attributes\u200b
    -------------
    
        particle_type : :class:`ParticleType`
            The enum instance that specifies which particle is this.
    
    **Supported Comparisons**

        ``a == b``: Checks if two particles have the same :class:`ParticleType` enum value.

        ``a != b``: Same as ``not a == b``.

    """
    __slots__ = ("particle_type",)
    particle_type: ParticleType

    def set(self, particle_type: ParticleType) -> "DFParticle":
        """Immediately set the type of this :class:`DFParticle`. Note that this is not changed dynamically,
        in DiamondFire. For that, use a dynamic variable.

        Parameters
        ----------
        particle_type : :class:`ParticleType`
            The new particle type.


        Returns
        -------
        :class:`DFParticle`
            self to allow chaining

        """
        if not isinstance(particle_type, ParticleType):
            raise TypeError("Particle type must be an instance of ParticleType enum.")

        self.particle_type = particle_type

        return self

    def to_item(self):
        pass  # TODO: Sparkly thing and stuff

    def as_json_data(self) -> dict:
        """Representation of this :class:`DFParticle` as a valid json-serializable :class:`dict`.

        Returns
        -------
        :class:`dict`
            JSON data.
        """
        return dict(
            id=constants.ITEM_ID_PARTICLE,
            data=dict(
                particle=self.particle_type.value
            )
        )

    @classmethod
    def from_json_data(cls: typing.Type["DFParticle"], data: dict) -> "DFParticle":
        """Obtain :class:`DFParticle` from pre-existing parsed JSON data.

        Parameters
        ----------
        data : :class:`dict`
            The parsed JSON :class:`dict`.

        Returns
        -------
        :class:`DFParticle`
            :class:`DFParticle` instance.

        """
        if (
            not isinstance(data, dict)
            # or "id" not in data  # not really required
            or "data" not in data
            or not isinstance(data["data"], dict)
            or "particle" not in data["data"]
            or not type("particle") == str
        ):
            raise TypeError(
                "Malformed DFSound parsed JSON data! Must be a dict with, at least, a 'data' dict and a particle value."
            )

        return cls(ParticleType(data["data"]["particle"]))

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} particle_type={self.particle_type.value}>"

    def __str__(self) -> str:
        return str(self.particle_type.value)

    def __eq__(self, other: "DFParticle") -> bool:
        return type(self) == type(other) and self.particle_type == other.particle_type

    def __ne__(self, other: "DFParticle") -> bool:
        return not self.__eq__(other)


class DFCustomSpawnEgg:
    """Used for the custom spawn egg types provided by DiamondFire (Giant, Iron Golem etc.)

    Attributes\u200b
    ---------------

        egg_type : :class:`py2df.enums.dftypes.CustomSpawnEggType`
            The enum instance that specifies which spawn egg is this.


    **Supported Comparisons**

        ``a == b``: Checks if two :class:`DFCustomSpawnEgg` instances have the same `egg_type` attribute.

        ``a != b``: Same as ``not a == b``

    """
    __slots__ = ("egg_type",)
    egg_type: CustomSpawnEggType

    def __init__(self, egg_type: CustomSpawnEggType):
        self.egg_type = CustomSpawnEggType(egg_type)

    def set(self, egg_type: CustomSpawnEggType) -> "DFCustomSpawnEgg":
        """Immediately set the type of this :class:`DFParticle`. Note that this is not changed dynamically,
        in DiamondFire. For that, use a dynamic variable.

        Parameters
        ----------
        egg_type : :class:`CustomSpawnEggType`
            The new spawn egg type.

        Returns
        -------
        :class:`DFCustomSpawnEgg`
            self to allow chaining

        """
        if not isinstance(egg_type, CustomSpawnEggType):
            raise TypeError("Egg type must be an instance of CustomSpawnEggType enum.")

        self.egg_type = egg_type

        return self

    def __post_init__(self):
        if not isinstance(self.egg_type, CustomSpawnEggType):
            raise TypeError("Egg type must be an instance of CustomSpawnEggType enum.")

    def to_item(self):
        pass  # TODO: egg lol

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} egg_type={self.egg_type.value}>"

    def __str__(self) -> str:
        return str(self.egg_type.value)

    def __eq__(self, other: "DFCustomSpawnEgg") -> bool:
        return type(self) == type(other) and self.egg_type == other.egg_type

    def __ne__(self, other: "DFCustomSpawnEgg") -> bool:
        return not self.__eq__(other)

    # TODO: Figure out json for Custom Spawn Egg;


class DFPotion:
    """
    Used for potion effects in potion-effect-related actions.

    Attributes\u200b
    --------------

        effect : :class:`PotionEffect`
            The PotionEffect enum instance that specifies which potion effect this :class:`DFPotion` represents.

        amplifier : :class:`int`
            Represents the strength of the effect. This should vary between -255 and 255.

        duration: Tuple[:class:`int`, :class:`int`]
            Tuple (:class:`int`, :class:`int`). Represents the duration of the effect in the form (min, seconds).

    **Supported Comparisons**

        ``a == b``: Checks if two :class:`DFPotion` instances have the same `effect`, `amplifier` and `duration`
        attributes.

        ``a != b``: Same as `not a == b`

        ``a > b``, ``a >= b``, ``a < b``, ``a <= b``: Applies the respective comparisons on the amplifiers of the
        potions.

    **Supported Operations**
    
        ``a + b``, ``a - b``, ``a * b``, ``a / b``, ``a // b``, ``a % b``, ``a ** b``: Applies the respective operations
        between the amplifiers of the potions, generating a new :class:`DFPotion` (e.g. amplifier 5 pot - amplifier 2
        pot = amplifier 3 pot). Worth noting that those operations also work between one :class:`DFPotion` and one
        :class:`int`/:class:`float`, however the result is always rounded down, since amplifiers can only
        be `:class:`int``s. (e.g. :class:`DFPotion`(amp=5) + 6 => :class:`DFPotion`(amp=11))
    
        ``a += b``, ``a -= b``, ...: Applies each of the operations above, in a similar fashion.
    
        ``:func:`ceil`(a)``, ``:func:`floor`(a)``, ``:func:`abs`(a)``, ``+a``: Returns the class itself.
    
        ``:class:`bool`(a)``: Returns whether or not the duration is bigger than 00:00 (tuple > (0,0) ).
    """
    __slots__ = ("effect", "amplifier", "duration")

    effect: PotionEffect
    amplifier: int
    duration: typing.Tuple[int, int]

    def __init__(self, effect: PotionEffect, *, amplifier: int = 1, duration: typing.Iterable[int] = (0, 5)):
        """
        Init this :class:`DFPotion`.

        :param effect: The effect that this :class:`DFPotion` represents.
        :param amplifier: An amplifier :class:`int`.
        :param duration: A duration in the form (:class:`int`, :class:`int`). Can be any Iterable with two ints.
        """
        self.effect = PotionEffect(effect)
        self.amplifier = int(amplifier)
        self.duration = typing.cast(typing.Tuple[int, int], tuple(map(int, duration))[:2])

    def set(
        self, effect: PotionEffect = DEFAULT_VAL,
        *, amplifier: int = DEFAULT_VAL, duration: typing.Iterable[int] = DEFAULT_VAL
    ) -> "DFPotion":
        """Set certain attributes of this :class:`DFPotion`. Specify `constants.DEFAULT_VAL` to not change one.

        Parameters
        ----------
        effect : `PotionEffect`
            The new potion effect.
        amplifier : :class:`int`
            The new amplifier.
        duration : Iterable[:class:`int`]
            The new duration.

        Returns
        -------
        :class:`DFPotion`
            self for chaining

        """
        if effect != DEFAULT_VAL:
            self.effect = PotionEffect(effect)

        if amplifier != DEFAULT_VAL:
            self.amplifier = int(amplifier)

        if duration != DEFAULT_VAL:
            self.duration = typing.cast(typing.Tuple[int, int], tuple(map(int, duration))[:2])

        return self

    def as_json_data(self) -> dict:
        """Returns this :class:`DFPotion` as a valid json serializable :class:`dict`.

        Returns
        -------
        :class:`dict`
        """
        return dict(
            id=constants.ITEM_ID_POTION,
            data=dict(
                pot=self.effect.value,
                dur=None,  # TODO: Figure out dur json; milliseconds?
                amp=self.amplifier
            )
        )

    def from_json_data(self) -> dict:
        pass  # TODO: Figure out dur json then implement this

    def copy(self) -> "DFPotion":
        """Creates an identical copy of this :class:`DFPotion`.

        Returns
        -------
        :class:`DFPotion`
            Copied :class:`DFPotion` instance.
        """
        return DFPotion(self.effect, amplifier=self.amplifier, duration=self.duration)

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} effect={self.effect.value} amplifier={self.amplifier} \
duration={self.duration[0]}:{self.duration[1]}>"

    def __str__(self) -> str:
        return str(self.effect.value)

    def __bool__(self) -> bool:
        return self.duration > (0, 0)

    def __eq__(self, other: "DFPotion") -> bool:
        return type(self) == type(other) and self.effect == other.effect and self.amplifier == other.amplifier \
            and self.duration == other.duration

    def __ne__(self, other: "DFPotion") -> bool:
        return not self.__eq__(other)

    def __gt__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier > other.amplifier

    def __ge__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier >= other.amplifier

    def __lt__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier < other.amplifier

    def __le__(self, other: "DFPotion") -> bool:
        if not type(self) == type(other) or not self.effect == other.effect:
            raise TypeError(f"DFPotion must be compared with another DFPotion of same effect.")

        return self.amplifier <= other.amplifier

    def __add__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be added with another DFPotion of same effect, or with an int/float.")

        copy = self.copy()
        copy.amplifier += other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __radd__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        return self.__add__(other)

    def __mul__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be multiplied with another DFPotion of same effect, or with an int/float.")

        copy = self.copy()
        copy.amplifier *= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __rmul__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        return self.__mul__(other)

    def __sub__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier -= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __pow__(self, other: typing.Union["DFPotion", AnyNumber], modulo=None) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(
                f"DFPotion must be taken to the power of another DFPotion of same effect, or of an int/float."
            )

        copy = self.copy()
        copy.amplifier = int(pow(
            copy.amplifier, other.amplifier if isinstance(other, type(self)) else other,
            modulo
        ))
        return copy

    def __truediv__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier /= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __floordiv__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier //= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __mod__(self, other: typing.Union["DFPotion", AnyNumber]) -> "DFPotion":
        if (type(self) == type(other) or not self.effect == other.effect) or not type(other) in (int, float):
            raise TypeError(f"DFPotion must be subtracted from another DFPotion of same effect, or from an int/float.")

        copy = self.copy()
        copy.amplifier %= other.amplifier if isinstance(other, type(self)) else other
        copy.amplifier = int(copy.amplifier)
        return copy

    def __ceil__(self):
        return self

    def __floor__(self):
        return self

    def __pos__(self):
        return self

    def __abs__(self):
        return self


# TODO: GameValue


_classes = (Item, DFText, DFNumber, DFLocation, DFSound, DFParticle, DFCustomSpawnEgg, DFPotion)

DFType = typing.Union[
    Item, DFText, DFNumber, DFLocation, DFSound, DFParticle, DFCustomSpawnEgg, DFPotion
]  # TODO: GameValue etc

remove_u200b_from_doc(_classes)
